name: Continuous Deployment

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: write

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: task-manager-eks
  ECR_BACKEND_REPOSITORY: task-manager-backend
  ECR_FRONTEND_REPOSITORY: task-manager-frontend

jobs:
  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Deploy

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get commit SHA
        id: vars
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build and push backend
        run: |
          cd backend
          docker build -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }} .
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }}
          docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:latest
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:latest

      - name: Build and push frontend
        run: |
          cd frontend
          docker build -t ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }} .
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }}
          docker tag ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }} ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:latest
          docker push ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:latest

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Create namespace
        run: |
          kubectl create namespace task-manager --dry-run=client -o yaml | kubectl apply -f -

      - name: Create secrets
        run: |
          kubectl create secret generic task-manager-secrets \
            --namespace task-manager \
            --from-literal=database-url="${{ secrets.DATABASE_URL }}" \
            --from-literal=secret-key="${{ secrets.SECRET_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy backend
        run: |
          kubectl apply -f - <<'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: task-manager-backend
  namespace: task-manager
spec:
  replicas: 2
  selector:
    matchLabels:
      app: task-manager-backend
  template:
    metadata:
      labels:
        app: task-manager-backend
    spec:
      containers:
      - name: backend
        image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }}
        ports:
        - containerPort: 5000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: database-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: task-manager-secrets
              key: secret-key
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 15
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: task-manager-backend
  namespace: task-manager
spec:
  selector:
    app: task-manager-backend
  ports:
  - port: 5000
    targetPort: 5000
  type: ClusterIP
EOF

      - name: Deploy frontend
        run: |
          kubectl apply -f - <<'EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: task-manager-frontend
  namespace: task-manager
spec:
  replicas: 2
  selector:
    matchLabels:
      app: task-manager-frontend
  template:
    metadata:
      labels:
        app: task-manager-frontend
    spec:
      containers:
      - name: frontend
        image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }}
        ports:
        - containerPort: 80
        env:
        - name: REACT_APP_API_URL
          value: /api
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: task-manager-frontend
  namespace: task-manager
spec:
  selector:
    app: task-manager-frontend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
EOF

      - name: Wait for deployments
        run: |
          kubectl rollout status deployment/task-manager-backend -n task-manager --timeout=5m
          kubectl rollout status deployment/task-manager-frontend -n task-manager --timeout=5m

      - name: Create ingress
        run: |
          kubectl apply -f - <<'EOF'
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: task-manager-ingress
  namespace: task-manager
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: task-manager-frontend
            port:
              number: 80
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: task-manager-backend
            port:
              number: 5000
EOF

      - name: Run database migrations
        run: |
          kubectl exec -n task-manager deployment/task-manager-backend -- flask db upgrade || true

      - name: Get application URL
        run: |
          sleep 30
          ALB_URL=$(kubectl get ingress -n task-manager -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          echo "Application URL: http://$ALB_URL" >> $GITHUB_STEP_SUMMARY

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ github.run_number }}
          name: Release v${{ github.run_number }}
          body: |
            ## Deployment v${{ github.run_number }}
            - Backend: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }}
            - Frontend: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPOSITORY }}:${{ steps.vars.outputs.sha_short }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}